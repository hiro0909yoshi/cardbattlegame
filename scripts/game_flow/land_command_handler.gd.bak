# LandCommandHandler - 領地コマンドの統合管理を担当
extends Node
class_name LandCommandHandler

## シグナル
signal land_command_opened()
signal land_command_closed()
signal land_selected(tile_index: int)
signal action_selected(action_type: String)

## 状態
enum State {
	CLOSED,              # 領地コマンド非表示
	SELECTING_LAND,      # 土地選択中
	SELECTING_ACTION,    # アクション選択中
	SELECTING_MOVE_DEST  # 移動先選択中
}

var current_state: State = State.CLOSED
var selected_tile_index: int = -1

## 参照
var ui_manager = null
var board_system = null
var game_flow_manager = null
var player_system = null

## コンポーネント
var selection_manager: LandSelectionManager = null
var action_executor: LandActionExecutor = null
var input_handler: LandInputHandler = null

func _ready():
	# コンポーネントを作成
	selection_manager = LandSelectionManager.new()
	add_child(selection_manager)
	
	action_executor = LandActionExecutor.new()
	add_child(action_executor)
	
	input_handler = LandInputHandler.new()
	add_child(input_handler)
	
	# シグナル接続
	_connect_signals()

func _process(delta):
	# 選択マーカーを回転
	if selection_manager:
		selection_manager.rotate_selection_marker(delta)

## 初期化
func initialize(ui_mgr, board_sys, flow_mgr, player_sys = null):
	ui_manager = ui_mgr
	board_system = board_sys
	game_flow_manager = flow_mgr
	player_system = player_sys
	
	# player_systemが渡されない場合はboard_systemから取得
	if not player_system and board_system:
		player_system = board_system.player_system
	
	# コンポーネントを初期化
	if selection_manager:
		selection_manager.initialize(board_system, ui_manager, player_system)
	
	if action_executor:
		action_executor.initialize(board_system, ui_manager, game_flow_manager, player_system, selection_manager)
	
	if input_handler:
		input_handler.initialize(selection_manager, action_executor)
	
	# UIManagerのシグナルを接続
	if ui_manager and ui_manager.has_signal("level_up_selected"):
		ui_manager.level_up_selected.connect(_on_level_up_selected)

## シグナル接続
func _connect_signals():
	# SelectionManager のシグナル
	if selection_manager:
		selection_manager.land_previewed.connect(_on_land_previewed)
		selection_manager.land_confirmed.connect(_on_land_confirmed)
	
	# ActionExecutor のシグナル
	if action_executor:
		action_executor.action_completed.connect(_on_action_completed)
		action_executor.move_destination_changed.connect(_on_move_destination_changed)
	
	# InputHandler のシグナル
	if input_handler:
		input_handler.cancel_requested.connect(_on_cancel_requested)
		input_handler.land_confirmed.connect(_on_input_land_confirmed)
		input_handler.action_selected.connect(_on_input_action_selected)
		input_handler.move_confirmed.connect(_on_input_move_confirmed)

# ============================================
# 公開API
# ============================================

## 領地コマンドを開く
func open_land_command(player_id: int):
	if current_state != State.CLOSED:
		print("[LandCommandHandler] 既に開いています")
		return
	
	# 土地選択を開始
	if not selection_manager.start_selection(player_id):
		return
	
	# 土地選択モードに移行
	current_state = State.SELECTING_LAND
	selected_tile_index = selection_manager.get_selected_tile()
	
	# 入力を有効化
	if input_handler:
		input_handler.set_input_state(LandInputHandler.InputState.LAND_SELECTION)
	
	land_command_opened.emit()
	print("[LandCommandHandler] 領地コマンドを開きました")

## 領地コマンドを閉じる
func close_land_command():
	# 入力を無効化
	if input_handler:
		input_handler.disable_input()
	
	# 選択をクリア
	if selection_manager:
		selection_manager.clear_selection()
	
	# 移動先選択をクリア
	if action_executor:
		action_executor.clear_move_destinations()
	
	current_state = State.CLOSED
	selected_tile_index = -1
	land_command_closed.emit()
	
	print("[LandCommandHandler] 領地コマンドを閉じました")
	
	# カメラを現在のプレイヤーに戻す
	if board_system and player_system and board_system.movement_controller:
		var player_id = player_system.current_player_index
		var player_tile_index = board_system.movement_controller.get_player_tile(player_id)
		
		if board_system.camera and board_system.tile_nodes.has(player_tile_index):
			var tile_pos = board_system.tile_nodes[player_tile_index].global_position
			
			# MovementControllerと同じカメラオフセットを使用
			const CAMERA_OFFSET = Vector3(19, 19, 19)
			var new_camera_pos = tile_pos + Vector3(0, 1.0, 0) + CAMERA_OFFSET
			
			board_system.camera.position = new_camera_pos
			board_system.camera.look_at(tile_pos + Vector3(0, 1.0, 0), Vector3.UP)
	
	# UIを非表示
	if ui_manager and ui_manager.has_method("hide_land_command_ui"):
		ui_manager.hide_land_command_ui()

## アクション実行
func execute_action(action_type: String) -> bool:
	if current_state != State.SELECTING_ACTION:
		print("[LandCommandHandler] アクション選択モードではありません")
		return false
	
	if selected_tile_index == -1:
		print("[LandCommandHandler] 土地が選択されていません")
		return false
	
	print("[LandCommandHandler] アクション実行: ", action_type, " on tile ", selected_tile_index)
	
	var result = false
	
	match action_type:
		"level_up":
			result = action_executor.execute_level_up(selected_tile_index)
		"move_creature":
			result = action_executor.execute_move_creature(selected_tile_index)
			if result:
				# 移動先選択モードに移行
				current_state = State.SELECTING_MOVE_DEST
				if input_handler:
					input_handler.set_input_state(LandInputHandler.InputState.MOVE_DESTINATION)
		"swap_creature":
			result = action_executor.execute_swap_creature(selected_tile_index)
		_:
			print("[LandCommandHandler] 不明なアクション: ", action_type)
	
	return result

## キャンセル処理
func cancel():
	if current_state == State.SELECTING_MOVE_DEST:
		# 移動先選択中ならアクション選択に戻る
		current_state = State.SELECTING_ACTION
		print("[LandCommandHandler] アクション選択に戻りました")
		
		# マーカーを移動元（選択中の土地）に戻す
		if selection_manager:
			selection_manager.show_selection_marker(selected_tile_index)
			selection_manager.focus_camera_on_tile(selected_tile_index)
		
		# 移動先リストをクリア
		if action_executor:
			action_executor.clear_move_destinations()
		
		# 入力状態を変更
		if input_handler:
			input_handler.set_input_state(LandInputHandler.InputState.ACTION_SELECTION)
		
		# UIを更新（アクションメニューを再表示）
		if ui_manager and ui_manager.has_method("show_action_menu"):
			ui_manager.show_action_menu(selected_tile_index)
		
	elif current_state == State.SELECTING_ACTION:
		# アクション選択中なら土地選択に戻る
		current_state = State.SELECTING_LAND
		selected_tile_index = -1
		print("[LandCommandHandler] 土地選択に戻りました")
		
		# 入力状態を変更
		if input_handler:
			input_handler.set_input_state(LandInputHandler.InputState.LAND_SELECTION)
		
		# マーカーを非表示
		if selection_manager:
			selection_manager.hide_selection_marker()
		
		if ui_manager and ui_manager.has_method("show_land_selection_mode"):
			var owned_lands = selection_manager.get_owned_lands()
			ui_manager.show_land_selection_mode(owned_lands)
	
	elif current_state == State.SELECTING_LAND:
		# 土地選択中なら閉じる
		close_land_command()

## カード選択時の処理（交換モード用）
func on_card_selected_for_swap(card_index: int):
	if action_executor:
		action_executor.on_card_selected_for_swap(card_index)
	
	# 交換完了後は閉じる
	close_land_command()

# ============================================
# シグナルハンドラ
# ============================================

## 土地プレビュー時
func _on_land_previewed(tile_index: int):
	selected_tile_index = tile_index

## 土地確定時（SelectionManagerから）
func _on_land_confirmed(tile_index: int):
	# アクション選択モードに移行
	current_state = State.SELECTING_ACTION
	selected_tile_index = tile_index
	
	# 入力状態を変更
	if input_handler:
		input_handler.set_input_state(LandInputHandler.InputState.ACTION_SELECTION)
	
	land_selected.emit(tile_index)
	
	print("[LandCommandHandler] 土地を確定: ", tile_index)
	
	# アクション選択UIを表示
	if ui_manager and ui_manager.has_method("show_action_menu"):
		ui_manager.show_action_menu(tile_index)

## 土地確定時（InputHandlerから）
func _on_input_land_confirmed():
	if selection_manager:
		selection_manager.confirm_selection()

## アクション完了時
func _on_action_completed(action_type: String, success: bool):
	print("[LandCommandHandler] アクション完了: ", action_type, " success=", success)
	
	# レベルアップまたは交換の場合は領地コマンドを閉じてターン終了
	if action_type == "level_up" and success:
		close_land_command()
		if game_flow_manager and game_flow_manager.has_method("end_turn"):
			game_flow_manager.end_turn()
	
	# 移動の場合も領地コマンドを閉じる（既にActionExecutorで閉じられている場合もある）
	elif action_type == "move_creature":
		if current_state != State.CLOSED:
			close_land_command()

## 移動先変更時
func _on_move_destination_changed(tile_index: int):
	pass  # 必要に応じて処理を追加

## キャンセル要求時（InputHandlerから）
func _on_cancel_requested():
	cancel()

## アクション選択時（InputHandlerから）
func _on_input_action_selected(action_type: String):
	execute_action(action_type)

## 移動確定時（InputHandlerから）
func _on_input_move_confirmed():
	if action_executor:
		action_executor.confirm_move()

## レベルアップ選択時（UIから）
func _on_level_up_selected(target_level: int, cost: int):
	if action_executor:
		var success = action_executor.execute_level_up_with_level(selected_tile_index, target_level, cost)
		if success:
			# 既にActionExecutorでaction_completedが発行されているので、ここでは何もしない
			pass

# ============================================
# 状態取得
# ============================================

## 現在の状態を取得
func get_current_state() -> State:
	return current_state

## 土地選択中か
func is_selecting_land() -> bool:
	return current_state == State.SELECTING_LAND

## アクション選択中か
func is_selecting_action() -> bool:
	return current_state == State.SELECTING_ACTION

# ============================================
# 後方互換性（旧APIのサポート）
# ============================================

## 土地をプレビュー（互換性のため）
func preview_land(tile_index: int) -> bool:
	if selection_manager:
		return selection_manager.preview_land(tile_index)
	return false

## 土地選択を確定（互換性のため）
func confirm_land_selection() -> bool:
	if selection_manager:
		return selection_manager.confirm_selection()
	return false

## 土地選択（旧メソッド - 互換性のため残す）
func select_land(tile_index: int) -> bool:
	return preview_land(tile_index)

## レベルアップ実行（互換性のため）
func execute_level_up() -> bool:
	if action_executor:
		return action_executor.execute_level_up(selected_tile_index)
	return false

## レベルアップ実行（レベル選択後・互換性のため）
func execute_level_up_with_level(target_level: int, cost: int) -> bool:
	if action_executor:
		return action_executor.execute_level_up_with_level(selected_tile_index, target_level, cost)
	return false

## クリーチャー移動実行（互換性のため）
func execute_move_creature() -> bool:
	if action_executor:
		return action_executor.execute_move_creature(selected_tile_index)
	return false

## クリーチャー交換実行（互換性のため）
func execute_swap_creature() -> bool:
	if action_executor:
		return action_executor.execute_swap_creature(selected_tile_index)
	return false

## 移動を確定（互換性のため）
func confirm_move(dest_tile_index: int):
	if action_executor:
		action_executor.confirm_move()

## 隣接タイルを取得（互換性のため）
func get_adjacent_tiles(tile_index: int) -> Array:
	if action_executor:
		return action_executor.get_adjacent_tiles(tile_index)
	return []

## プレイヤーの所有地を取得（互換性のため）
func get_player_owned_lands(player_id: int) -> Array:
	if selection_manager:
		return selection_manager.get_player_owned_lands(player_id)
	return []

## 選択マーカーを作成（互換性のため）
func create_selection_marker():
	if selection_manager:
		selection_manager.create_selection_marker()

## 選択マーカーを表示（互換性のため）
func show_selection_marker(tile_index: int):
	if selection_manager:
		selection_manager.show_selection_marker(tile_index)

## 選択マーカーを非表示（互換性のため）
func hide_selection_marker():
	if selection_manager:
		selection_manager.hide_selection_marker()

## 選択マーカーを回転（互換性のため）
func rotate_selection_marker(delta: float):
	if selection_manager:
		selection_manager.rotate_selection_marker(delta)

## カメラフォーカス（互換性のため）
func focus_camera_on_tile(tile_index: int):
	if selection_manager:
		selection_manager.focus_camera_on_tile(tile_index)

## 移動先選択UIを更新（互換性のため）
func update_move_destination_ui():
	if action_executor:
		action_executor.update_move_destination_ui()

## 土地選択UIを更新（互換性のため）
func update_land_selection_ui():
	if selection_manager:
		selection_manager.update_ui()

## キーボード入力処理（互換性のため、実際の処理はInputHandlerで行う）
func _input(event):
	# InputHandlerが処理するため、ここでは何もしない
	pass

## 各種入力ハンドラ（互換性のため、実際の処理はInputHandlerで行う）
func handle_land_selection_input(event):
	pass  # InputHandlerが処理

func handle_action_selection_input(event):
	pass  # InputHandlerが処理

func handle_move_destination_input(event):
	pass  # InputHandlerが処理
