# CPU AI 仕組みの理解メモ

**作成日**: 2025年1月  
**目的**: CPU AIの考え方を理解するためのメモ

---

## 1. 基本的な考え方

### AIの判断方法は「点数ベース」

CPUが行動を決めるとき、各選択肢に点数をつけて、一番高い点数の行動を選ぶ。

例えば召喚フェーズで以下の選択肢があるとする：
- 空き地にクリーチャー召喚 → 35点
- 移動侵略でタイル5へ攻める → 60点（最高）
- 自分の土地をレベルアップ → 45点
- クリーチャーを交換 → 20点
- 何もしない → 0点

この場合、60点の「移動侵略」が選ばれる。

---

## 2. フェーズごとに選択肢を比較する

重要なポイント：**同じフェーズ内の選択肢だけを比較する**

召喚フェーズで可能な行動：
- 空き地にクリーチャー召喚
- 移動侵略（自クリーチャーを移動して戦闘）
- 領地レベルアップ
- クリーチャー交換
- 何もしない（パス）

これらは全て同じフェーズの選択肢なので、並行して評価が必要。

戦闘フェーズで可能な行動：
- 戦う
- 通行料を払う

スペルフェーズで可能な行動：
- スペルAを使う
- スペルBを使う
- 使わない

---

## 3. CPUの性格（プロファイル）

同じ評価の仕組みでも、CPUごとに性格を変えられる。

やり方：各行動の点数に「倍率」をかける。

例：
- 攻撃的なCPU → 侵略の点数を1.5倍、レベルアップの点数を0.8倍
- 守備的なCPU → 侵略の点数を0.7倍、レベルアップの点数を1.5倍

同じ状況でも、攻撃的なCPUは侵略を選び、守備的なCPUはレベルアップを選ぶ。

これはJSONファイルで設定できる。既にai_profilesフォルダがある。

---

## 4. 難易度レベルによる評価の深さ

難易度が上がると、より多くのことを考慮する。

レベル0：評価しない（ランダムか使わない）
レベル1：基礎的な評価のみ（カテゴリで判断）
レベル2：詳細な評価（個別設定も使う）

例えばスペル使用の場合：
- レベル0のCPU → スペルを使うかどうか適当
- レベル1のCPU → ダメージ系スペルは敵がいれば使う、程度の判断
- レベル2のCPU → このスペルでこのクリーチャーを倒せるか計算して判断

---

## 5. 方向選択のロジック

分岐点で進む方向を決める方法。

各方向について以下を計算：
- 次の分岐点まで何マスか
- その間に敵クリーチャーが何体いるか
- 通行料の合計はいくらか

通行料が高い方向はスコアが低くなり、避ける傾向になる。

### 諦めロジック

同じ分岐点で何度も同じ方向を避けていると、いつまでも進めなくなる。
そこで「回避回数」を記録し、2-3回避けたら諦めてその方向に進む。

例：
- 1回目：左は通行料200G、右は50G → 右を選択
- 2回目：また同じ分岐点 → また右を選択
- 3回目：「もう諦めよう」ボーナスが左に加算 → 左を選択

---

## 6. スペル使用の判断

### 問題：スペルが100個以上ある

全部個別に設定するのは大変。

### 解決策：カテゴリ別に評価

既にスペルのJSONには「effect_type」がある。これでグループ化できる。

土地属性変更系：
- change_element
- change_element_bidirectional
- change_element_to_dominant

ダメージ系：
- damage

EP操作系：
- drain_magic
- gain_magic

このカテゴリごとにAI評価を設定すれば、10-15個の設定で100個以上のスペルをカバーできる。

### CPU用のJSON

スペル本体のJSONを汚さないよう、CPU用の評価設定は別ファイルにする。
IDとAI評価だけを定義し、CPUクラスから参照する。

---

## 7. 点数ベース以外の方法について

議論した結果、以下のことがわかった。

### 他の方法

**ルールベース**
「〜なら〜する」の条件分岐を優先度順に並べる。

**ゴール指向**
目標から逆算して行動を決める。例：4000G必要 → 通行料で稼ぐ → 高レベル土地が必要 → レベルアップ優先

**状態マシン**
ゲーム状況で「モード」を切り替える。序盤は土地確保、中盤はレベルアップ、終盤は妨害・防衛。

### 結論

どの方法を選んでも、「このカードは何ができるか」をAIに教える必要がある。

- 点数ベース → 状況ごとにスコアで教える
- ルールベース → 条件分岐で教える
- タグベース → 事前分類で教える

教え方が違うだけで、教える量は変わらない。

現実的には、effect_typeが既にカテゴリ分けしてくれているので、これを活用するのが一番楽。

最終的には**組み合わせ**になる：
1. 状態マシンで大方針を決める（序盤/中盤/終盤）
2. ルールベースで「やるべきこと」を絞る
3. 点数ベースで最終選択

---

## 8. 現状の実装状況（2026年1月更新）

### 実装済みファイル構成

```
scripts/cpu_ai/
├── cpu_ai_handler.gd          # エントリーポイント、各AIクラスの初期化・呼び出し
├── cpu_turn_processor.gd      # CPUターン処理フロー制御
├── cpu_battle_ai.gd           # バトル評価、アイテム選択、ワーストケース判定
├── cpu_merge_evaluator.gd     # 合体判断ロジック
├── battle_simulator.gd        # バトル結果シミュレーター
├── cpu_spell_ai.gd            # スペル使用判断
├── cpu_mystic_arts_ai.gd      # ミスティックアーツ使用判断
├── cpu_spell_condition_checker.gd  # スペル使用条件判定
├── cpu_target_resolver.gd     # ターゲット条件解決
├── cpu_spell_target_selector.gd    # 最適ターゲット選択
├── cpu_spell_utils.gd         # 距離・利益計算ユーティリティ
├── cpu_board_analyzer.gd      # 盤面分析ヘルパー
└── cpu_hand_utils.gd          # 手札アクセスユーティリティ
```

### 実装済み機能

**バトル判断（cpu_battle_ai.gd）**
- BattleSimulatorによる正確な勝敗シミュレーション
- クリーチャー×アイテムの全組み合わせ評価
- ワーストケース判定（敵の対抗手段を考慮）
- 合体判断（最優先）
- 即死スキル判断（最後の手段）
- 無効化+即死優先判断
- アイテム破壊/盗みスキル対策

**スペル/秘術判断（cpu_spell_ai.gd, cpu_mystic_arts_ai.gd）**
- cpu_ruleフィールドによるパターン別評価
- ターゲット条件による自動ターゲット選択
- 損益計算（profit_calc）
- 戦略的判断（strategic）

**防御側判断（item_phase_handler.gd）**
- 無効化スキルで勝てるならパス
- 合体判断（最優先）
- 防具温存ロジック
- 援護判断
- 温存対象アイテム/クリーチャー判定

### 未実装機能

- 難易度レベルによる評価の深さ変更
- CPU性格プロファイル（倍率調整）
- 方向選択の詳細評価
- シナジー評価

---

## 9. 今後作るもの（残タスク）

### 優先度高

1. **方向選択の詳細評価**
   - 分岐点での方向選択ロジック
   - 通行料・危険度の計算
   - 諦めロジック（回避回数記録）

### 優先度中

2. **難易度レベル**
   - Level 1: 基礎ステータスのみ
   - Level 2: バフ・スキル考慮
   - Level 3: 全スキル考慮、先読み

3. **CPU性格プロファイル**
   - 攻撃的/守備的などの性格設定
   - JSONで倍率を定義

### 優先度低（将来）

4. **シナジー評価**
   - デッキごとのカード組み合わせ評価

5. **先読み機能**
   - 2ターン先までの状況予測

---

## 10. クエストとの連携

既にステージ定義に以下が設定できる構造になっている：
- character_id：CPUキャラクター
- deck_id：使用デッキ
- ai_profile_id：AI難易度・性格

クエストJSONでこれらを指定すれば、そのステージでのCPUの振る舞いが決まる。

---

## 11. バトルシミュレーション（勝敗判断）

### 問題：CPUが正確に勝敗を判断できるか？

現状のcpu_ai_handler.gdでは基礎AP/HPのみで判断している。
実際のバトルではアイテムやスキルでステータスが大きく変わる。

### 解決策：既存のバトル処理を流用する

良いニュース：battle_preparation.gdとbattle_item_applier.gdに全ての計算ロジックが既にある。
新規で計算ロジックを書く必要がない。

やること：BattleSimulatorという薄いラッパーを作り、既存処理を「実行せずに結果だけ取得」する。

### 計算できるバフの種類（27種類）

以下は全て既存コードで計算できる：

**配置数・土地数系**
- 属性別配置数×倍率（element_count_bonus）
- 敵と同属性の自分の配置数×倍率（same_element_as_enemy_count）
- 自領地数×倍率（owned_land_count_bonus）
- 連鎖数×倍率（chain_count_ap_bonus）

**手札・その他**
- 手札数×倍率（hand_count_multiplier）
- 属性不一致時ボーナス（element_mismatch_bonus）

**戦闘地・条件系**
- 戦闘地属性条件（battle_land_element_bonus）
- 戦闘地レベルボーナス（battle_land_level_bonus）
- 敵属性条件（enemy_element_bonus）

**その他全て**
- 土地数比例、常時補正、破壊数比例、ターン数ボーナス、防御時固定APなど

詳細は conditional_stat_buff_system.md を参照。

### 強打などの条件付きスキルも計算できる

強打は「条件を満たすとAP×1.5」のようなスキル。

例：水属性の敵と戦う時のみAP×1.5

これも既存コードで対応済み：
1. skill_power_strike.gd - 強打の適用ロジック
2. condition_checker.gd - 強打の条件判定（敵属性チェック含む）

CPUシミュレーションでも同じ処理を呼べるので、新規実装は不要。

### 最終的なAP/HPが正確に出せる

バフ計算 → 強打などの倍率適用 → 最終AP/HP

この流れを既存コードで全てシミュレーションできる。

---

## 12. コンボとカウンターの判断

### コンボとは

特定のカードの組み合わせで、通常より有利に戦える状況。

例：石化＋反転コンボ
- 石化アイテム：敵のHPとAPを入れ替える
- 反転アイテム：ステータスを反転させる
- 結果：どんな敵でも倒せる

### 正確な数値計算ができるので、コンボは少なくて済む

バフや強打を含めた最終AP/HPが正確に出せるなら、
多くの状況は「計算して勝てるか判断」で対応できる。

コンボとして特別扱いが必要なのは、計算だけでは判断できないケース。
具体的には10個未満の見込み。

### カウンターの判断

コンボが使えない状況を判断する必要がある。

例：石化＋反転コンボの弱点
- 敵が「攻撃無効化」アイテムを持っている
- 敵が「防魔」スキルを持っている

CPUは「このコンボを使おうとしたが、敵がカウンターを持っているので使わない」と判断する。

### コンボの定義方法

JSONで定義する：

コンボID、名前、必要なアイテム、効果、カウンター条件

CPUがアイテム選択時：
1. 手札にコンボパーツが揃っているか確認
2. 揃っていれば、敵がカウンターを持っているか確認
3. カウンターがなければコンボを使う

---

## 13. 移動系スペルの戦略的判断

### 目標ベースの逆算

移動系スペルは「どこに行きたいか」から逆算して使う。

2つのパターンがある：

**攻撃パターン**
- 状況：勝てる高価値タイル（高レベル敵地）がある
- 行動：そこに行くスペルを使う
- 例：3マス先に勝てるレベル4敵地 → ホーリーワード3を使用

**回避パターン**
- 状況：勝てない危険タイル（高レベル敵地）がある
- 行動：そこを避けるスペルを使う
- 例：3マス先に勝てないレベル4敵地 → 6進むスペルで回避

### 処理の流れ

```
スペルフェーズ開始時:

1. 盤面スキャン
   → 自分の位置から各タイルまでの距離を計算
   → 各タイルの「価値」と「危険度」を計算

2. 通常移動（ダイス1〜6）で止まりうるタイルを分析
   → タイル1〜6のリスクと報酬を計算

3. パターン判定
   A) 危険回避が必要？
	  → 勝てない高レベル敵がいる → 危険
	  → 回避スペルがあるか探す
   
   B) 攻撃チャンスがある？
	  → 勝てる高価値タイルがある
	  → そこに行けるスペルがあるか探す

4. スコア比較
   → 回避の価値（払わずに済む通行料）
   → 攻撃の価値（奪える土地の価値）
   → 高い方を選択
```

### 具体例：攻撃

```
状況:
  自分の位置: タイル0
  タイル3: 敵のレベル4土地（通行料400G）
  手札: ホーリーワード3（3マス移動確定）

処理:
  1. タイル3は高価値（レベル4）
  2. 距離は3マス
  3. BattleSimulator → 勝てる
  4. ホーリーワード3で3マス進める → 採用
  5. スコア: 土地価値 + 侵略成功ボーナス = 高スコア

結果: ホーリーワード3を使う
```

### 具体例：回避

```
状況:
  自分の位置: タイル0
  タイル3: 敵のレベル4土地（通行料400G）
  手札: ホーリーワード6（6マス移動確定）

処理:
  1. タイル3は危険（レベル4、勝てない）
  2. 通行料: 400G
  3. BattleSimulator → 負ける
  4. ホーリーワード6で6マス進める → タイル3を回避
  5. 回避価値: 400G（払わずに済む）

結果: ホーリーワード6を使う
```

### 必要な機能

| 機能 | 内容 |
|------|------|
| TileScanner | 盤面をスキャンして価値と危険度を計算 |
| PathCalculator | 自分の位置から各タイルまでの距離 |
| SpellMoveAnalyzer | 移動系スペルで行ける場所を計算 |
| DangerAnalyzer | 各タイルの危険度（負ける＆通行料）を計算 |
| BattleSimulator | そこで勝てるか計算 |

### 移動系スペルの分類

effect_typeで識別する：

- dice_fixed：ダイス固定（ホーリーワードN）
- dice_range：ダイス範囲指定
- warp_to_target：指定場所にワープ
- warp_to_nearest_vacant：最寄り空き地にワープ
- move_steps：マス移動

### スペル選択の優先度

```
1. 回避必須の危険がある？ → 回避スペル優先
2. 攻撃チャンスがある？ → 攻撃スペル
3. どちらもない → スペル使わない or 別の用途
```

---

## 14. ルール決め（特殊スキル判断）

コンボとは別に、特殊な状況判断のルールが必要。

### 例：特殊スキルの考慮

反射：攻撃が跳ね返ってくる
無効化：攻撃が効かない
変身：バトル中に別のクリーチャーになる

これらは単純なAP/HP比較では判断できない。

### 対応方法

難易度によって考慮するルールを変える：

低難易度CPU：基礎ステータスのみで判断（特殊スキルは考慮しない）
中難易度CPU：重要なスキル（無効化、反射）だけ考慮
高難易度CPU：全てのスキルを考慮

### ルールの数

コンボ：10個未満
特殊スキル判断ルール：15〜20個程度（スキルの種類による）

全て個別に書く必要があるが、スペルのように100個以上にはならない。

---

## 15. スペル/秘術AI 実装状況（2026年1月）

スペルJSONの`cpu_rule`フィールドで使用できるパターンと条件の一覧。

### cpu_rule の構造

```json
"cpu_rule": {
  "pattern": "has_target",
  "target_condition": "enemy_creature",
  "priority": "medium"
}
```

---

### pattern（判断パターン）

| pattern | 状態 | 説明 | 使用例 |
|---------|------|------|--------|
| `immediate` | ✅ 実装済 | 手に入り次第すぐ使用 | ドロー系、セルフバフ |
| `has_target` | ✅ 実装済 | 有効なターゲットがいれば使用 | ダメージ、呪い付与 |
| `condition` | ✅ 実装済 | 特定条件を満たしたら使用 | 属性変更、状況依存系 |
| `enemy_hand` | ✅ 実装済 | 敵の手札を見て判断 | カード破壊、奪取系 |
| `profit_calc` | ⚠️ 枠組みのみ | 損益計算して判断 | EP獲得系（計算式未実装多数） |
| `strategic` | ⚠️ 仮実装 | 戦略的判断（30%ランダム） | ダイス操作、世界呪い |
| `skip` | ✅ 実装済 | CPUは使用しない | 複雑すぎるスペル |

---

### priority（優先度）

| priority | スコア値 | 説明 |
|----------|---------|------|
| `high` | 3.0 | 最優先で使用 |
| `medium_high` | 2.5 | 高め |
| `medium` | 2.0 | 標準 |
| `low` | 1.0 | 低め |
| `very_low` | 0.5 | 最低 |

---

### target_condition（ターゲット条件）

`has_target`パターンで使用。ターゲットが見つかれば使用する。

#### クリーチャー属性フィルター

| target_condition | 説明 |
|------------------|------|
| `fire_wind_creature` | 火/風属性の敵クリーチャー |
| `water_earth_creature` | 水/地属性の敵クリーチャー |
| `fire_earth_creature` | 火/地属性の敵クリーチャー |
| `water_wind_creature` | 水/風属性の敵クリーチャー |
| `fire_water_creature` | 火/水属性の敵クリーチャー |
| `earth_wind_creature` | 地/風属性の敵クリーチャー |
| `neutral_creature` | 無属性の敵クリーチャー |

#### 所有者フィルター

| target_condition | 説明 |
|------------------|------|
| `enemy_creature` | 敵クリーチャー全般 |
| `own_creature` | 自クリーチャー全般 |

#### 状態フィルター

| target_condition | 説明 |
|------------------|------|
| `element_mismatch_creatures` | 土地属性と不一致のクリーチャー |
| `cursed_creatures` | 呪いがかかっているクリーチャー |
| `hp_reduced` | HPが減っているクリーチャー |
| `low_mhp_creatures` | MHP30以下のクリーチャー |
| `downed_high_mhp` | ダウン中でMHP高いクリーチャー |

#### 特殊条件

| target_condition | 説明 |
|------------------|------|
| `can_kill_target` | ダメージ値で倒せる敵クリーチャー |
| `most_common_element` | 最も多い属性のクリーチャー |
| `has_summon_condition` | 召喚条件を持つクリーチャー |
| `no_curse_no_mystic` | 呪いも秘術もないクリーチャー |
| `has_mystic_arts` | 秘術を持つクリーチャー |

#### プレイヤー条件

| target_condition | 説明 |
|------------------|------|
| `enemy_has_2_items` | アイテム2枚以上持つ敵プレイヤー |
| `enemy_has_high_toll` | 高通行料土地を持つ敵プレイヤー |
| `enemy_has_more_magic` | 自分よりEPが多い敵プレイヤー |

#### 土地条件

| target_condition | 説明 |
|------------------|------|
| `enemy_has_land_bonus` | 土地ボーナスを得ている敵土地 |
| `own_no_land_bonus` | 土地ボーナスがない自土地 |

---

### condition（使用条件）

`condition`パターンで使用。条件を満たしたら使用する。

#### 属性・土地関連

| condition | 説明 |
|-----------|------|
| `element_mismatch` | 土地と属性不一致の自クリーチャーがいる |
| `enemy_high_level` | 敵のレベル3以上土地がある |
| `enemy_level_4` | 敵のレベル4土地がある |

#### クリーチャー状態

| condition | 説明 |
|-----------|------|
| `has_downed_creature` | ダウン中の自クリーチャーがいる |
| `self_creature_damaged` | HPが減った自クリーチャーがいる |
| `has_cursed_creature` | 呪い付きクリーチャーがいる |
| `standing_on_vacant_land` | 空き地に止まっている |

#### クリーチャー交換

| condition | 説明 |
|-----------|------|
| `can_upgrade_creature` | 手札クリーチャーで属性一致に改善可能 |
| `swap_improves_element_match` | 交換で属性一致が改善される |

#### 呪い関連

| condition | 説明 |
|-----------|------|
| `has_any_curse` | 何らかの呪いがある |
| `has_world_curse` | 世界呪いがある |
| `has_player_curse` | プレイヤー呪いがある |

#### その他

| condition | 説明 |
|-----------|------|
| `has_unvisited_gate` | 未通過ゲートがある（2つ以上） |
| `nearest_checkpoint_unvisited` | 最寄りチェックポイントが未訪問 |

---

### デフォルト動作（target_conditionなしの場合）

`has_target`で`target_condition`を指定しない場合、`effect_parsed.target_type`と`target_info.owner_filter`から自動判定：

| target_type | owner_filter | 動作 |
|-------------|--------------|------|
| `creature` | `enemy` | 敵クリーチャーを対象 |
| `creature` | `own` | 自クリーチャーを対象 |
| `player` | `enemy` | 敵プレイヤーを対象 |
| `land` | any | 土地を対象 |

---

### 設定例

```json
// ダメージ系：倒せるターゲットがいれば使用
"cpu_rule": {
  "pattern": "has_target",
  "target_condition": "can_kill_target",
  "priority": "medium"
}

// 回復系：HPが減った味方がいれば使用
"cpu_rule": {
  "pattern": "has_target",
  "target_condition": "hp_reduced",
  "priority": "medium"
}

// ドロー系：即座に使用
"cpu_rule": {
  "pattern": "immediate",
  "priority": "low"
}

// 属性変更：属性不一致土地があれば使用
"cpu_rule": {
  "pattern": "condition",
  "condition": "element_mismatch",
  "priority": "low"
}

// 複雑すぎるので使用しない
"cpu_rule": {
  "pattern": "skip"
}
```

---

## 変更履歴

| 日付 | 内容 |
|------|------|
| 2025/01 | 初版作成：CPU AIの仕組みについての理解メモ |
| 2025/01 | 追記：バトルシミュレーション、コンボ、ルール決めについて |
| 2025/01 | 追記：移動系スペルの戦略的判断（攻撃・回避パターン） |
| 2025/01 | 追記：実装順序確定、難易度3段階、テスト方法（思考ログ） |
| 2025/01 | BattleSimulator実装完了（scripts/cpu_ai/battle_simulator.gd） |
| 2026/01 | セクション8「現状の実装状況」を実装済み内容に更新 |
| 2026/01 | セクション9「今後作るもの」を残タスクに整理 |
| 2026/01 | セクション15「condition」一覧を実装済みのみに更新（未使用削除反映） |
