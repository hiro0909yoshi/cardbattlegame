# 死者復活スキル

**プロジェクト**: カルドセプト風カードバトルゲーム  
**バージョン**: 1.3  
**最終更新**: 2025年10月31日

---

## 📋 目次

1. [概要](#概要)
2. [発動タイミング](#発動タイミング)
3. [復活タイプ](#復活タイプ)
4. [条件システム](#条件システム)
5. [ステータス処理](#ステータス処理)
6. [実装クリーチャー](#実装クリーチャー)
7. [データ構造](#データ構造)
8. [他スキルとの相互作用](#他スキルとの相互作用)
9. [実装コード](#実装コード)
10. [設計思想](#設計思想)

---

## 概要

クリーチャーが撃破されたとき、別のクリーチャーに変身して戦闘を継続する防御的スキル。

**最大の特徴**: 
- タイルを守り抜く最終防衛手段
- 復活後は**永続変身**（交換してもそのクリーチャーのまま）
- 「ある意味無敵」のスキル

---

## 発動タイミング

### on_death（撃破時）

- **タイミング**: クリーチャーのHPが0以下になった瞬間
- **発動条件**: 条件を満たしている場合のみ
- **効果**: 別のクリーチャーとして復活し、**攻撃せずに戦闘終了**

**重要**: 
- 即死スキルで撃破された場合も発動
- 復活後は攻撃フェーズをスキップ（v1.3で変更）
- 復活したクリーチャーはそのまま土地に残る

---

## 復活タイプ

### 1. 強制復活 (`forced`)
- 無条件で指定されたクリーチャーに復活
- 例: ヘルグラマイト → サーペントフライ

### 2. 条件付き復活 (`conditional`)
- 特定条件を満たしたときのみ復活
- 例: リビングアムル → リビングアーマー（敵が武器未使用時）

---

## 条件システム

### enemy_item_not_used（敵アイテム未使用）

相手が特定カテゴリのアイテムを使用していないときに発動。

- **判定**: `item_type`フィールドをチェック
- **指定可能**: "武器"、"防具"、"巻物"
- **例**: `"item_category": "武器"` → 敵が武器未使用時に復活

---

## ステータス処理

### 復活時のステータス更新

1. **基本ステータス**: 復活先クリーチャーの値を使用
   - `base_hp` → 復活先のHP（全回復）
   - `current_ap` → 復活先のAP

2. **アイテムボーナス**: **引き継ぐ**
   - `item_bonus_hp` → 保持
   - アイテム効果 → 継続適用

3. **土地ボーナス**: **再計算**
   - 復活先クリーチャーの属性で土地ボーナスを再計算
   - 感応効果も復活先の条件で再判定

4. **現在HP**: **全回復**
   - `update_current_hp()`で最大HPに設定
   - 土地ボーナス + アイテムボーナスを含む

### 処理フロー

```
撃破直前: リビングアムル AP:20, HP:-20 (撃破)
↓
条件チェック: 敵が武器使用？ → No
↓
復活実行（ID: 438 リビングアーマー）
↓
復活後: AP:0, HP:40 (全回復)
  + 土地ボーナス再計算
  + アイテムボーナス引き継ぎ
↓
戦闘継続（防御側の攻撃ターン）
```

---

## 実装クリーチャー

### 実装済み（4体+1アイテム）

| 種類 | ID | 名前 | 復活タイプ | 復活先 | 復活先ID | 条件 |
|-----|----|----|----------|-------|---------|-----|
| クリーチャー | 439 | リビングアムル | 条件付き | リビングアーマー | 438 | 敵が武器未使用 |
| クリーチャー | 139 | ヘルグラマイト | 強制 | サーペントフライ | 316 | なし |
| クリーチャー | 411 | グレートフォシル | 強制 | ティラノサウルス | 425 | なし |
| アイテム | 1045 | ネクロマンサーリング | 強制 | スケルトン | 420 | なし |

**注**: アイテムの死者復活は、アイテム使用者が撃破されたときに発動

---

## データ構造

死者復活効果は`ability_parsed.effects`配列に以下の形式で記述：

```json
{
  "effect_type": "revive",
  "trigger": "on_death",
  "revive_type": "forced" または "conditional",
  "creature_id": 復活先のID,
  "condition": {
	"type": "enemy_item_not_used",
	"item_category": "武器"
  }
}
```

**詳細**: 各クリーチャーのJSONファイルを参照

---



## 実装コード

**実装箇所**: `scripts/skills/transform_processor.gd`

主要な処理:
1. `check_and_apply_revive()` - 死者復活チェックと適用
2. `_check_revive_condition()` - 条件判定
3. `_apply_revive()` - 復活実行（変身処理を流用）

**詳細**: 実装ファイルを参照

---



---

## 設計思想

### 防御的スキルの最終手段
- タイルを守り抜く最後の砦
- 強力だが条件付きや弱いクリーチャーへの復活で調整

### 変身システムとの統合
- 変身処理を流用して実装
- ステータス処理が統一されている

---

## 変更履歴

| バージョン | 日付 | 変更内容 |
|-----------|------|---------|
| 1.3 | 2025/10/31 | 仕様変更：復活後は攻撃せずに戦闘終了するように変更 |
| 1.2 | 2025/10/25 | ドキュメント簡潔化（冗長な部分を削減） |
| 1.1 | 2025/10/24 | バグ修正：復活後のクリーチャーが手札/タイルに正しく反映されるように修正 |
| 1.0 | 2025/10/24 | 初版作成：死者復活スキル実装完了 |

---

## バグ修正履歴

### 2025/10/24 - 復活後のクリーチャーが手札/タイルに反映されない問題

**問題**: 死者復活した後に両者生存で戦闘終了すると、復活**前**のクリーチャーが手札に戻る

**例**: ヘルグラマイト → サーペントフライに復活 → 両者生存 → **ヘルグラマイト**が手札に戻る ❌

**原因**: `BattleResult.ATTACKER_SURVIVED`の処理で、元の`card_data`を手札に戻していた

**修正内容**:
```gdscript
// 修正前
card_system_ref.return_card_to_hand(attacker_index, card_data)

// 修正後
var return_card_data = attacker.creature_data.duplicate(true)
// HPは元の最大値にリセット（手札に戻る時はダメージを回復）
// duplicate(true)で元のHPが既にコピーされているので上書きしない
card_system_ref.return_card_to_hand(attacker_index, return_card_data)
```

**影響**: 復活後のクリーチャー（`attacker.creature_data`）が正しく手札に戻るようになった

---

### 2025/10/24 - タイル情報に`has_creature`フィールドがない問題

**問題**: 死者復活後にクリーチャー交換しようとすると、`tile_info.has_creature`が`false`になり交換が失敗

**原因**: `tile_data_manager.get_tile_info()`が`has_creature`フィールドを返していなかった

**修正内容**:
```gdscript
// 修正前
return {
	"creature": tile.creature_data,
	// has_creatureフィールドがない
}

// 修正後
return {
	"creature": tile.creature_data,
	"has_creature": not tile.creature_data.is_empty(),
}
```

---

### 2025/10/31 - 復活後に第2攻撃が実行される問題

**問題**: 死者復活後も戦闘が継続し、復活したクリーチャーが攻撃してしまう

**原因**: 
- `break`は内側の`for`ループ（攻撃回数ループ）から抜けるだけ
- 外側の`for`ループ（攻撃順ループ）は継続され、第2攻撃が実行される

**修正内容**:
1. 戦闘終了フラグ`battle_ended`を追加
2. 復活時に`battle_ended = true`を設定
3. 外側ループの開始時に`battle_ended`をチェック

```gdscript
// 戦闘終了フラグの追加
var battle_ended = false

for i in range(attack_order.size()):
	// 復活時の戦闘終了チェック
	if battle_ended:
		break
	
	// ... 攻撃処理 ...
	
	if revive_result["revived"]:
		print("  【死者復活成功】", revive_result["new_creature_name"], "として復活！")
		battle_result["defender_revived"] = true
		print("  → 復活したため、攻撃せずに戦闘終了")
		battle_ended = true  // フラグを設定
		break
```

**影響**: 復活後は攻撃フェーズをスキップし、戦闘が即座に終了するようになった

**影響**: クリーチャーの存在を正しく判定できるようになり、交換が正常に動作するようになった
