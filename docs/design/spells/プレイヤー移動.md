# プレイヤー移動スペル設計

**最終更新**: 2025年12月1日 | **実装状況**: ⏳ 未実装

---

## 概要

プレイヤー（セプター）の位置を直接移動させる、または移動に関する効果を付与するスペル。  
ワープ系と移動制御系の2カテゴリーに分類。

---

## 実装スペル一覧

### ワープ系（位置移動）

| ID | 名前 | コスト | 効果 | ターゲット | レアリティ |
|----|------|--------|------|-----------|-----------|
| 2014 | エスケープ | 30MP | 最も近い空地に飛ぶ | none | R |
| 2079 | フォームポータル | 40MP | 最も近いゲートに飛ぶ | none | R |
| 2104 | マジカルリープ | 60MP | 距離1～4マスの対象の土地に飛ぶ | land | S |

### 移動制御系

| ID | 名前 | コスト | 効果 | ターゲット | レアリティ |
|----|------|--------|------|-----------|-----------|
| 2019 | カオスパニック | 80MP | 全セプターに呪い"歩行逆転" | world | S |
| 2123 | リミッション | 50MP | 対象ゲートを通過したことになる | unvisited_gate | R |
| 9021 | 方向選択権付与 | 40G | 次R、対象セプターは選んだ方向に進める | player | 秘術 |

> **9021**: クロックアウル（ID: 412）の秘術として実装

---

## 距離計算仕様

### すごろく的距離（タイル個数）

ワープ系スペルの「最も近い」はマップ経路上のタイル数で計算：

```gdscript
## BFSでタイル間距離を計算
func calculate_tile_distance(from_tile: int, to_tile: int) -> int:
	if from_tile == to_tile:
		return 0
	
	var visited = {}
	var queue = [[from_tile, 0]]  # [tile_index, distance]
	visited[from_tile] = true
	
	while not queue.is_empty():
		var current = queue.pop_front()
		var tile = current[0]
		var dist = current[1]
		
		# 隣接タイル（すごろく的な前後）を取得
		var neighbors = get_sequential_neighbors(tile)
		
		for neighbor in neighbors:
			if neighbor == to_tile:
				return dist + 1
			if not visited.has(neighbor):
				visited[neighbor] = true
				queue.append([neighbor, dist + 1])
	
	return -1  # 到達不可
```

**注意**: 空間的距離（XZ座標）ではなく、経路上のタイル数をカウント

---

## 効果タイプ詳細

### warp_to_nearest_vacant（最寄り空地ワープ）

**対象スペル**: エスケープ (2014)

- **効果**: 使用者を最も近い空地（クリーチャーのいない土地）に移動
- **距離計算**: すごろく経路上のタイル個数
- **同距離の場合**: 進行方向優先
- **空地がない場合**: 効果なし（魔力消費あり）

**JSON定義**:
```json
{
  "id": 2014,
  "name": "エスケープ",
  "cost": {"mp": 30},
  "effect_parsed": {
	"target_type": "none",
	"effects": [
	  {
		"effect_type": "warp_to_nearest_vacant"
	  }
	]
  }
}
```

---

### warp_to_nearest_gate（最寄りゲートワープ）

**対象スペル**: フォームポータル (2079)

- **効果**: 使用者を最も近いゲートに移動
- **ゲート定義**: CheckpointTile（周回判定用タイル）
- **距離計算**: すごろく経路上のタイル個数
- **ゲート到着後**: ゲート効果を発動
  - **ゲート通過扱い**（周回フラグ更新）
  - **ダウン解除**（全クリーチャーのダウン状態解除）

**JSON定義**:
```json
{
  "id": 2079,
  "name": "フォームポータル",
  "cost": {"mp": 40},
  "effect_parsed": {
	"target_type": "none",
	"effects": [
	  {
		"effect_type": "warp_to_nearest_gate"
	  }
	]
  }
}
```

**実装メソッド**:
```gdscript
func warp_to_nearest_gate(player_id: int) -> Dictionary:
	# 1. 現在位置取得
	# 2. 全ゲートタイルを列挙
	# 3. 最短距離のゲートを計算
	# 4. プレイヤーをワープ
	# 5. ゲート効果を発動（通過扱い + ダウン解除）
	# 6. 結果を返す {success: bool, from: int, to: int}
```

---

### warp_to_target_tile（指定タイルワープ）

**対象スペル**: マジカルリープ (2104)

- **効果**: 使用者を選択した土地に移動
- **距離制限**: 1～4マス以内（すごろく経路）
- **ターゲット選択**: UI表示（範囲内の土地を選択可能）
- **空地制限**: なし（敵領地にも飛べる）

**JSON定義**:
```json
{
  "id": 2104,
  "name": "マジカルリープ",
  "cost": {"mp": 60},
  "effect_parsed": {
	"target_type": "land",
	"target_info": {
	  "distance_min": 1,
	  "distance_max": 4
	},
	"effects": [
	  {
		"effect_type": "warp_to_target"
	  }
	]
  }
}
```

---

### reverse_movement（歩行逆転呪い）

**対象スペル**: カオスパニック (2019)

- **効果**: 全セプターの移動方向を逆転
- **呪いタイプ**: `movement_reverse`
- **持続**: 1ターン
- **影響**: 進行方向が反対になる（分岐選択も反転）

**JSON定義**:
```json
{
  "id": 2019,
  "name": "カオスパニック",
  "cost": {"mp": 80},
  "effect_parsed": {
	"target_type": "world",
	"effects": [
	  {
		"effect_type": "curse_movement_reverse",
		"duration": 1
	  }
	]
  }
}
```

**呪いデータ構造**:
```gdscript
player.curse = {
	"curse_type": "movement_reverse",
	"name": "歩行逆転",
	"duration": 1,
	"params": {}
}
```

**方向選択権との組み合わせ**:

歩行逆転中に方向選択権がある場合、逆転をベースとして選択可能：

| 選択 | 実際の移動方向 |
|------|----------------|
| 「逆方向」選択 | 逆転の逆 = 順方向 |
| 「順方向」選択 | 逆転のまま = 逆方向 |

```gdscript
func get_final_direction(player_id: int, chosen_direction: int) -> int:
	var player = player_system.players[player_id]
	var base_direction = 1
	
	# 歩行逆転呪いチェック
	if player.curse.get("curse_type") == "movement_reverse":
		base_direction = -1
	
	# 方向選択権で選んだ方向を適用
	return base_direction * chosen_direction
```

---

### grant_direction_choice（方向選択権付与）

**対象**: クロックアウル秘術 (9021)

- **効果**: 対象セプターに「方向選択権」を付与
- **持続**: 1ターン（次のターンの移動時のみ有効）
- **発動タイミング**: ダイスを振った後、移動開始前に方向を選択

**JSON定義（spell_mystic.json）**:
```json
{
  "id": 9021,
  "name": "方向選択権付与（クロックアウル秘術）",
  "type": "mystic",
  "effect_parsed": {
	"target_type": "player",
	"target_info": {
	  "target_filter": "any"
	},
	"effects": [
	  {
		"effect_type": "grant_direction_choice",
		"duration": 1,
		"name": "方向選択"
	  }
	]
  }
}
```

**プレイヤーバフ構造**:
```gdscript
player.buffs["direction_choice"] = {
	"name": "方向選択",
	"duration": 1,  # 残りターン数
	"source": "クロックアウル"
}
```

**MovementController統合**:
```gdscript
func get_available_directions(player_id: int) -> Array:
	var player = player_system.players[player_id]
	
	# 方向選択権があれば両方向を返す
	if player.buffs.has("direction_choice"):
		return [1, -1]  # 順方向、逆方向
	
	# 歩行逆転呪いチェック
	if player.curse.get("curse_type") == "movement_reverse":
		return [-1]
	
	return [1]  # 通常は順方向のみ

func consume_direction_choice(player_id: int):
	var player = player_system.players[player_id]
	if player.buffs.has("direction_choice"):
		player.buffs.erase("direction_choice")
```

---

### gate_pass（ゲート通過効果）

**対象スペル**: リミッション (2123)

- **効果**: 指定ゲートを通過したことにする
- **移動なし**: プレイヤー位置は変わらない
- **周回フラグ更新**: 選択したゲートのフラグをtrueに

**選択条件**:
1. **未通過のゲートのみ選択可能**（フラグがfalseのゲート）
2. **1周完了を引き起こすゲートは選択不可**

**選択可否の判定例（4ゲート: A, B, C, D）**:

| 現在の状態 | 選択可能なゲート | 理由 |
|------------|------------------|------|
| A=false, B=false, C=false, D=false | A, B, C, D | どれを選んでも1周にならない |
| A=true, B=false, C=true, D=false | B, D | どれを選んでも1周にならない |
| A=true, B=true, C=true, D=false | **なし** | Dを選ぶと1周完了になる |

**JSON定義**:
```json
{
  "id": 2123,
  "name": "リミッション",
  "cost": {"mp": 50},
  "effect_parsed": {
	"target_type": "unvisited_gate",
	"effects": [
	  {
		"effect_type": "gate_pass"
	  }
	]
  }
}
```

**実装メソッド**:
```gdscript
## 選択可能なゲートを取得
func get_selectable_gates(player_id: int) -> Array:
	var lap_state = game_flow_manager.player_lap_state[player_id]
	var selectable = []
	
	# 未通過ゲートを列挙
	var unvisited = []
	for gate_key in lap_state.keys():
		if not lap_state[gate_key]:
			unvisited.append(gate_key)
	
	# 1周完了を引き起こすゲートを除外
	for gate_key in unvisited:
		if not _would_complete_lap(player_id, gate_key):
			selectable.append(gate_key)
	
	return selectable

## このゲートを通過すると1周完了になるか
func _would_complete_lap(player_id: int, gate_key: String) -> bool:
	var lap_state = game_flow_manager.player_lap_state[player_id]
	
	# 仮にこのゲートを通過した場合をシミュレート
	for key in lap_state.keys():
		if key == gate_key:
			continue  # このゲートは通過済みとして扱う
		if not lap_state[key]:
			return false  # 他に未通過があれば1周にならない
	
	return true  # 全て通過済み = 1周完了

## ゲート通過効果を発動
func trigger_gate_pass(player_id: int, gate_key: String) -> Dictionary:
	# ゲートフラグを更新
	game_flow_manager.player_lap_state[player_id][gate_key] = true
	
	return {
		"success": true,
		"gate": gate_key,
		"message": "%s を通過しました" % gate_key
	}
```

---

## ゲートシステム仕様

### 現在の実装（2ゲート）

```gdscript
# タイル0: CheckpointTile (N)
# タイル10: CheckpointTile (S)
player_lap_state[player_id] = {"N": false, "S": false}
```

### 拡張設計（最大4ゲート）

```gdscript
# マップごとにゲート構成を定義
var map_gates = {
	"default": ["N", "S"],           # 2ゲート
	"large": ["N", "E", "S", "W"]    # 4ゲート
}

# 周回判定: 全ゲートがtrueで1周完了
func _check_lap_complete(player_id: int) -> bool:
	var lap_state = player_lap_state[player_id]
	for gate_key in lap_state.keys():
		if not lap_state[gate_key]:
			return false
	return true
```

### ゲートタイル識別

```gdscript
# CheckpointTileかどうかを判定
func is_gate_tile(tile_index: int) -> bool:
	var tile = board_system.tile_nodes.get(tile_index)
	return tile and tile.has_signal("checkpoint_passed")

# ゲートキーを取得
func get_gate_key(tile_index: int) -> String:
	var tile = board_system.tile_nodes.get(tile_index)
	if tile and tile.has_method("get_checkpoint_type"):
		return tile.get_checkpoint_type()  # "N", "S", etc.
	return ""
```

---

## ターゲットタイプ

| target_type | 説明 | 使用スペル |
|-------------|------|-----------|
| `none` | ターゲット選択なし（自動発動） | エスケープ、フォームポータル |
| `land` | 土地選択（距離制限あり） | マジカルリープ |
| `world` | 全体効果 | カオスパニック |
| `unvisited_gate` | 未通過ゲート選択（1周完了除外） | リミッション |

### 新規ターゲットタイプ: unvisited_gate

未通過かつ1周完了を引き起こさないゲートのみ選択可能：

```gdscript
# TargetSelectionHelper に追加
static func get_unvisited_gates(handler, player_id: int) -> Array:
	var targets = []
	var selectable = handler.spell_player_move.get_selectable_gates(player_id)
	
	for gate_key in selectable:
		var tile_index = _get_tile_index_for_gate(handler.board_system, gate_key)
		if tile_index >= 0:
			targets.append({
				"type": "gate",
				"tile_index": tile_index,
				"gate_key": gate_key
			})
	
	return targets

static func _get_tile_index_for_gate(board_system, gate_key: String) -> int:
	for tile_index in board_system.tile_nodes.keys():
		var tile = board_system.tile_nodes[tile_index]
		if tile.has_signal("checkpoint_passed"):
			var type_str = "N" if tile.checkpoint_type == 0 else "S"
			if type_str == gate_key:
				return tile_index
	return -1
```

---

## アーキテクチャ

### クラス構成

```
scripts/spells/
  └── spell_player_move.gd    # プレイヤー移動処理（新規作成）

GameFlowManager
  └── spell_player_move: SpellPlayerMove
```

### SpellPlayerMove クラス

```gdscript
class_name SpellPlayerMove

var board_system: BoardSystem3D
var player_system: PlayerSystem
var game_flow_manager: GameFlowManager
var spell_curse: SpellCurse

func setup(board: BoardSystem3D, player: PlayerSystem, flow: GameFlowManager, curse: SpellCurse):
	board_system = board
	player_system = player
	game_flow_manager = flow
	spell_curse = curse

# ワープ系
func warp_to_nearest_vacant(player_id: int) -> Dictionary
func warp_to_nearest_gate(player_id: int) -> Dictionary
func warp_to_target(player_id: int, tile_index: int) -> Dictionary

# 移動制御系
func apply_movement_reverse_curse(duration: int) -> void
func trigger_gate_pass(player_id: int, gate_key: String) -> Dictionary
func grant_direction_choice(player_id: int, duration: int) -> void

# ゲート選択
func get_selectable_gates(player_id: int) -> Array

# ユーティリティ
func get_tiles_in_range(from_tile: int, min_dist: int, max_dist: int) -> Array
func find_nearest_tile(from_tile: int, condition: Callable) -> int
func calculate_tile_distance(from_tile: int, to_tile: int) -> int
```

---

## SpellPhaseHandler統合

### _apply_single_effect() への追加

```gdscript
"warp_to_nearest_vacant":
	result = spell_player_move.warp_to_nearest_vacant(player_id)

"warp_to_nearest_gate":
	result = spell_player_move.warp_to_nearest_gate(player_id)

"warp_to_target":
	result = spell_player_move.warp_to_target(player_id, target_data.tile_index)

"curse_movement_reverse":
	spell_player_move.apply_movement_reverse_curse(effect.get("duration", 3))

"gate_pass":
	result = spell_player_move.trigger_gate_pass(player_id, target_data.gate_key)

"grant_direction_choice":
	spell_player_move.grant_direction_choice(target_data.player_id, effect.get("duration", 1))
```

---

## 実装優先度

### Phase 1: 基盤構築
- [ ] `spell_player_move.gd` クラス作成
- [ ] `GameFlowManager` 統合（setup）
- [ ] 距離計算ユーティリティ実装（BFS）

### Phase 2: ワープ系実装
- [ ] 2014: エスケープ（最寄り空地）
- [ ] 2079: フォームポータル（最寄りゲート）
- [ ] 2104: マジカルリープ（指定タイル）

### Phase 3: 移動制御系実装
- [ ] 2019: カオスパニック（歩行逆転）
- [ ] 2123: リミッション（ゲート通過）
- [ ] 9021: 方向選択権付与（クロックアウル秘術）
- [ ] ゲート4つ対応のlap_state拡張

---

## 注意事項

### ワープ後の処理
- 基本的にワープ先での**停止効果は発動しない**（通行料、呪い発動等）
- **例外: フォームポータル** - ゲートへのワープ時はゲート効果を発動
  - ゲート通過扱い（周回フラグ更新）
  - ダウン解除（全クリーチャー）
- ワープは**移動フェーズ外**で発生（スペルフェーズ中）
- ワープ後、通常の移動フェーズは継続

### 歩行逆転の影響
- 分岐での選択肢も逆転
- ゲート通過方向も逆転
- 複数プレイヤーに同時適用

### ゲート通過効果（リミッション）
- 実際の移動なし（位置変更なし）
- 周回フラグのみ更新（ボーナス発動なし）
- **1周完了を引き起こすゲートは選択不可**

---

## 変更履歴

| 日付 | バージョン | 変更内容 |
|------|-----------|---------|
| 2025/12/01 | 1.0 | 初版作成 - 5スペルの設計定義 |
| 2025/12/01 | 1.1 | リミッション仕様詳細化、unvisited_gate追加、距離計算をBFS方式に更新 |
| 2025/12/01 | 1.2 | クロックアウル秘術（9021: 方向選択権付与）追加 |

---

**作成日**: 2025年12月1日
