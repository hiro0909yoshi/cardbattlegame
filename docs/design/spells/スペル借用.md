# スペル借用効果

**バージョン**: 1.0  
**最終更新**: 2025年12月2日

---

## 概要

手札のスペルカードや他クリーチャーの秘術を「借りて」使用する特殊効果。通常のスペル/秘術とは異なり、実行時に動的に効果を決定する。

---

## 対象カード一覧

### 秘術（1体）

| ID | 名前 | 属性 | コスト | 効果 | 状態 |
|----|------|------|--------|------|------|
| 147 | ルーンアデプト | 水 | G100 | 自手札のスペルカードの効果を使用 | ⏳ |

### スペル（1個）

| ID | 名前 | コスト | 効果 | 前提 | 状態 |
|----|------|--------|------|------|------|
| 2059 | テンプテーション | G70 + カード1枚 | 対象クリーチャーの秘術を使用 | cards_sacrifice実装 | ⏳ |

---

## 効果詳細

### ルーンアデプト（ID 147）の秘術

**効果**: 自分の手札にある「単体対象」スペルカードを1枚選択し、その効果を発動する

**処理フロー**:
```
1. 手札から「単体対象」スペルカード一覧を取得
2. CardSelectionHandler で手札スペル選択UI表示
3. 100G支払い（秘術コスト）
4. 選択されたスペルの effect_parsed を取得
5. 通常のスペル実行フローを実行（ターゲット選択含む）
6. 選択したスペルカードを手札から破棄
```

**特記事項**:
- 魔力コスト100Gのみ支払い
- **選択スペルのコストは完全無視**（mp、cards_sacrifice等すべて不要）
- 選択したスペルカードは使用後に破棄される
- 「単体対象」スペルがない場合は秘術使用不可（発動可能クリーチャー一覧に出さない）
- スペル選択後のキャンセル可能
- CardSelectionHandlerを拡張して手札選択UIを実装

### テンプテーション（ID 2059）

**効果**: 対象クリーチャーの秘術を使用する（自分が発動者となる）

**処理フロー**:
```
1. スペルコスト支払い（70G + カード1枚犠牲）
2. 秘術持ちクリーチャーをターゲット選択
3. 対象クリーチャーの秘術一覧を取得
4. 秘術選択UI表示（複数ある場合）
5. 選択された秘術を通常の秘術発動フローで実行
   - ターゲット選択（秘術のtarget_typeに従う）
   - 効果適用
6. 秘術のコストは無料（スペルコストで代替済み）
```

**特記事項**:
- スペルコスト（70G + カード1枚）のみ支払い
- **秘術の魔力コストは完全無料**
- 対象は敵・味方どちらも選択可能
- **ダウンしていないクリーチャーのみ対象可**
- 対象クリーチャーはダウン状態にならない
- 自分のクリーチャーもダウンしない
- 秘術を持たないクリーチャーは対象選択不可
- 秘術選択後のキャンセル可能
- 「秘術を使う」ボタン後の処理をそのまま再利用

---

## JSON定義

### ルーンアデプト（クリーチャー）- 直接effects方式

```json
{
  "id": 147,
  "name": "ルーンアデプト",
  "ability_parsed": {
    "keywords": ["巻物強打", "防魔", "秘術"],
    "keyword_conditions": {
      "巻物強打": {
        "scroll_type": "base_ap"
      }
    },
    "mystic_arts": [
      {
        "name": "スペル借用",
        "cost": 100,
        "effects": [
          {
            "effect_type": "use_hand_spell"
          }
        ]
      }
    ]
  }
}
```

### テンプテーション（スペル）

```json
{
  "id": 2059,
  "name": "テンプテーション",
  "rarity": "R",
  "type": "spell",
  "spell_type": "単体対象",
  "cost": {
    "mp": 70,
    "cards_sacrifice": 1
  },
  "effect_parsed": {
    "target_type": "creature",
    "target_info": {
      "owner_filter": "any",
      "requires_mystic_arts": true
    },
    "effects": [
      {
        "effect_type": "use_creature_mystic_art"
      }
    ]
  }
}
```

---

## 必要な新規effect_type

| effect_type | 説明 | 対象 |
|-------------|------|------|
| `use_hand_spell` | 手札のスペルカードを選択して使用 | ルーンアデプト |
| `use_creature_mystic_art` | 対象クリーチャーの秘術を使用 | テンプテーション |

---

## 実装

### クラス構成

`scripts/spells/spell_borrow.gd` を新規作成（SpellCreatureSwapと同様の構造）

```gdscript
class_name SpellBorrow

var board_system_ref: Object
var player_system_ref: Object
var card_system_ref: Object
var spell_phase_handler_ref: Object

func _init(board_sys: Object, player_sys: Object, card_sys: Object, spell_phase_handler: Object = null) -> void:
    board_system_ref = board_sys
    player_system_ref = player_sys
    card_system_ref = card_sys
    spell_phase_handler_ref = spell_phase_handler
```

---

### 手札スペル取得（ルーンアデプト用）

```gdscript
## 手札から「単体対象」スペルのみを取得
func _get_hand_single_target_spells(player_id: int) -> Array:
    if not card_system_ref:
        return []
    
    var hand = card_system_ref.get_all_cards_for_player(player_id)
    return hand.filter(func(card): 
        return card.get("type") == "spell" and card.get("spell_type") == "単体対象"
    )

## ルーンアデプト秘術の発動可能判定
func can_cast_rune_adept_mystic(player_id: int) -> bool:
    return _get_hand_single_target_spells(player_id).size() > 0
```

---

### 手札スペル選択UI（ルーンアデプト用）

SpellCreatureSwapの`_select_hand_creature()`を参考に実装

```gdscript
## 手札スペル選択UI
func _select_hand_spell(spells: Array, message: String) -> int:
    var ui_manager = null
    if spell_phase_handler_ref and spell_phase_handler_ref.ui_manager:
        ui_manager = spell_phase_handler_ref.ui_manager
    
    if not ui_manager:
        return 0 if spells.size() > 0 else -1
    
    # フィルターを単体対象スペルのみに設定
    ui_manager.card_selection_filter = "single_target_spell"
    
    if ui_manager.has_method("set_message"):
        ui_manager.set_message(message)
    
    # カード選択UIを表示
    var current_player_id = spell_phase_handler_ref.current_player_id
    if player_system_ref:
        var player = player_system_ref.players[current_player_id]
        ui_manager.show_card_selection_ui_mode(player, "spell_borrow")
    
    # カード選択を待つ
    var selected_index = await ui_manager.card_selected
    
    ui_manager.hide_card_selection_ui()
    
    # キャンセル判定
    if selected_index < 0:
        return -1
    
    # 選択されたカードがスペル配列内のインデックスを返す
    var hand = card_system_ref.get_all_cards_for_player(current_player_id)
    if selected_index < hand.size():
        var selected_card = hand[selected_index]
        for i in range(spells.size()):
            if spells[i].get("id") == selected_card.get("id"):
                return i
    
    return -1
```

---

### ルーンアデプト秘術メイン処理

```gdscript
## 手札スペル借用（ルーンアデプト秘術）
func apply_use_hand_spell(caster_player_id: int) -> Dictionary:
    # 1. 手札から単体対象スペルを取得
    var spells = _get_hand_single_target_spells(caster_player_id)
    if spells.is_empty():
        return {"success": false, "reason": "no_single_target_spell"}
    
    # 2. スペル選択UI
    var selected_index = await _select_hand_spell(spells, "使用するスペルを選択")
    if selected_index == -1:
        return {"success": false, "reason": "cancelled"}
    
    var selected_spell = spells[selected_index]
    
    # 3. 100G支払い（秘術コスト）
    player_system_ref.add_gold(caster_player_id, -100)
    
    # 4. 選択スペルの効果を実行（ターゲット選択含む）
    var effect_parsed = selected_spell.get("effect_parsed", {})
    await spell_phase_handler_ref._apply_spell_effects(effect_parsed, caster_player_id)
    
    # 5. スペルカードを手札から破棄
    var hand = card_system_ref.get_all_cards_for_player(caster_player_id)
    for i in range(hand.size()):
        if hand[i].get("id") == selected_spell.get("id"):
            card_system_ref.player_hands[caster_player_id]["data"].remove_at(i)
            break
    
    card_system_ref.emit_signal("hand_updated")
    
    return {
        "success": true,
        "spell_name": selected_spell.get("name", "スペル")
    }
```

---

### テンプテーションメイン処理

```gdscript
## 対象クリーチャーの秘術を借用（テンプテーション）
func apply_use_creature_mystic_art(target_data: Dictionary, caster_player_id: int) -> Dictionary:
    var tile_index = target_data.get("tile_index", -1)
    var tile = board_system_ref.tile_nodes.get(tile_index)
    
    if not tile or tile.creature_data.is_empty():
        return {"success": false, "reason": "no_creature"}
    
    var creature = tile.creature_data
    var ability_parsed = creature.get("ability_parsed", {})
    var mystic_arts = ability_parsed.get("mystic_arts", [])
    
    if mystic_arts.is_empty():
        return {"success": false, "reason": "no_mystic_arts"}
    
    # 秘術選択（1つなら自動、複数ならUI）
    var selected_art = mystic_arts[0]
    if mystic_arts.size() > 1:
        selected_art = await _select_mystic_art(mystic_arts)
        if selected_art == null:
            return {"success": false, "reason": "cancelled"}
    
    # 秘術を通常フローで実行（コストなし、ダウンなし）
    var context = {
        "player_id": caster_player_id,
        "skip_cost": true,
        "skip_down": true
    }
    await spell_phase_handler_ref.spell_mystic_arts.apply_mystic_art_effect(
        selected_art, {}, context
    )
    
    return {
        "success": true,
        "creature_name": creature.get("name", "クリーチャー"),
        "mystic_art_name": selected_art.get("name", "秘術")
    }
```

---

### テンプテーション用ターゲットフィルター

```gdscript
## 秘術持ち＋ダウンしていないクリーチャーのみフィルター
func filter_temptation_targets(targets: Array) -> Array:
    return targets.filter(func(t):
        var tile = board_system_ref.tile_nodes.get(t.tile_index)
        if not tile or tile.creature_data.is_empty():
            return false
        
        # ダウンチェック
        if tile.is_down:
            return false
        
        # 秘術持ちチェック
        var ability = tile.creature_data.get("ability_parsed", {})
        return ability.get("mystic_arts", []).size() > 0
    )
```

---

## 関連ドキュメント

- [秘術システム](../mystic_arts.md)
- [手札操作](./手札操作.md)
- [スペルシステム設計](../spells_design.md)

---

## 変更履歴

| 日付 | Ver | 内容 |
|------|-----|------|
| 2025/12/02 | 1.0 | 初版作成 |
